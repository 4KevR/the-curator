# TODO: THIS CLASS IS NOW UNUSED! DELETE!

import re
from typing import Optional

from typeguard import typechecked

from src.backend.modules.ai_assistant.chunked_card_stream import ChunkedCardStream
from src.backend.modules.search.llama_index import LlamaIndexExecutor
from src.backend.modules.ai_assistant.llm_interactor.llm_command_list import (
    LLMCommandList,
    llm_command,
)
from src.backend.modules.llm.abstract_llm import AbstractLLM
from src.backend.modules.search.abstract_card_searcher import AbstractCardSearcher
from src.backend.modules.search.llm_search_by_content import LLMSearchByContent
from src.backend.modules.search.search_by_substring import SearchBySubstring
from src.backend.modules.search.search_by_substring_fuzzy import SearchBySubstringFuzzy

# Easier words for the llm. The names are in the autogenerated prompt using @llm_command.
from src.backend.modules.srs.abstract_srs import (
    AbstractCard,
    AbstractDeck,
    AbstractSRS,
    AbstractTemporaryCollection,
    CardID,
    DeckID,
    TmpCollectionID,
)

_commands = LLMCommandList(
    {
        "AbstractDeck": "Deck",
        "AbstractCard": "Card",
        "AbstractTemporaryCollection": "TemporaryCollection",
    },
    card_type=AbstractCard,
    deck_type=AbstractDeck,
    temp_collection_type=AbstractTemporaryCollection,
)


@typechecked
class LLMInteractor:
    """
    A class that handles the interaction between the LLM and the SRS.
    """

    flashcard_manager: AbstractSRS[AbstractDeck, AbstractCard, AbstractTemporaryCollection]
    content_search_llm: AbstractLLM
    llama_index_executor: LlamaIndexExecutor
    command_list = _commands

    def __init__(
        self,
        flashcard_manager: AbstractSRS[AbstractDeck, AbstractCard, AbstractTemporaryCollection],
        content_search_llm: AbstractLLM,
        llama_index_executor: LlamaIndexExecutor,
    ):
        self.content_search_llm = content_search_llm
        self.flashcard_manager = flashcard_manager
        self.llama_index_executor = llama_index_executor

    def change_flashcard_manager(
        self,
        flashcard_manager: AbstractSRS[AbstractDeck, AbstractCard, AbstractTemporaryCollection],
    ):
        self.flashcard_manager = flashcard_manager

    @llm_command(_commands)
    def create_deck(self, name: str) -> AbstractDeck:
        """
        Create a new deck with the given name. The name must be a non-empty string.
        There may be no deck with the same name.
        The Deck containing the generated id is returned.
        """
        if not isinstance(name, str) or not name.strip():
            raise ValueError("Deck name must be a non-empty string.")

        deck = self.flashcard_manager.add_deck(name)
        return deck

    @llm_command(_commands)
    def list_decks(
        self,
    ) -> list[AbstractDeck]:
        """
        List all available decks. Necessary to get the ids of the decks.
        """
        return self.flashcard_manager.get_all_decks()

    @llm_command(_commands)
    def rename_deck(self, deck_id_str: str, new_name: str) -> None:
        """
        Rename a deck.
        """
        deck_id = DeckID.from_hex_string(deck_id_str)
        deck = self.flashcard_manager.get_deck(deck_id)
        self.flashcard_manager.rename_deck(deck, new_name)

    @llm_command(_commands)
    def delete_deck(self, deck_id_str: str) -> None:
        """
        Delete a deck by its id. The deck_id_str must be a string in the format 'deck_xxxx_xxxx'.
        """
        deck_id = DeckID.from_hex_string(deck_id_str)
        deck = self.flashcard_manager.get_deck(deck_id)
        self.flashcard_manager.delete_deck(deck)

    @llm_command(_commands)
    def add_card(self, deck_id_str: str, question: str, answer: str) -> None:
        """
        Create a new card in a deck. The deck id must be a string in the format 'deck_xxxx_xxxx'.
        The question and answer must all be non-empty strings.
        """
        if not all(isinstance(x, str) and x.strip() for x in [question, answer]):
            raise ValueError("Question, answer, state, and flag must all be non-empty strings.")
        deck_id = DeckID.from_hex_string(deck_id_str)
        deck = self.flashcard_manager.get_deck(deck_id)
        self.flashcard_manager.add_card(deck, question, answer)

    # @llm_command(_commands)
    def edit_card_question(self, card_id_str: str, new_question: str) -> None:
        """
        Edit the question of a card. The card_id_str must be a string in the format 'card_xxxx_xxxx'.
        """
        if not isinstance(new_question, str) or not new_question.strip():
            raise ValueError("New question must be a non-empty string.")
        card = self.flashcard_manager.get_card(CardID.from_hex_string(card_id_str))
        self.flashcard_manager.edit_card_question(card, new_question)

    # @llm_command(_commands)
    def edit_card_answer(self, card_id_str: str, new_answer: str) -> None:
        """
        Edit the answer of a card. The card_id_str must be a string in the format 'card_xxxx_xxxx'.
        """
        if not isinstance(new_answer, str) or not new_answer.strip():
            raise ValueError("New answer must be a non-empty string.")
        card = self.flashcard_manager.get_card(CardID.from_hex_string(card_id_str))
        self.flashcard_manager.edit_card_answer(card, new_answer)

    # @llm_command(_commands)
    def delete_card(self, card_id_str: str) -> None:
        """
        Delete a card by its id. The card_id_str must be a string in the format 'card_xxxx_xxxx'.
        """
        card = self.flashcard_manager.get_card(CardID.from_hex_string(card_id_str))
        self.flashcard_manager.delete_card(card)

    # @llm_search_command(_search_commands)
    def create_new_temporary_collection(self, temporary_collection_description: str) -> AbstractTemporaryCollection:
        """
        Creates a new, empty temporary collection with the given name.
        A temporary collection is a collection of cards that are part of (possibly different) decks.
        A temporary collection can be used to collect and store cards that will be the target of future operations.

        The temporary collection description may describe how the temporary collection was created or what its purpose is. It may be empty.
        """
        if not isinstance(temporary_collection_description, str):
            raise ValueError("Temporary collection name must be a non-empty string.")

        temporary_collection = self.flashcard_manager.create_temporary_collection(temporary_collection_description, [])
        return temporary_collection

    # @llm_command(_commands)
    def get_temporary_collections(self) -> list[AbstractTemporaryCollection]:
        """
        Returns all existing temporary collections.
        """
        return self.flashcard_manager.get_temporary_collections()

    # @llm_command(_commands)
    def delete_temporary_collection(self, temporary_collection_id_str: str) -> None:
        """
        Deletes the temporary collection with the given id.
        The temporary_collection_id_str must be a string in the format 'tmp_collection_xxxx_xxxx'.
        """
        tmp_col_id = TmpCollectionID.from_hex_string(temporary_collection_id_str)
        temporary_collection = self.flashcard_manager.get_temporary_collection(tmp_col_id)
        self.flashcard_manager.delete_temporary_collection(temporary_collection)

    # @llm_command(_commands)
    def temporary_collection_add_card(self, temporary_collection_str: str, card_id_str: str) -> None:
        """
        Adds the given card to the given temporary collection. Cards may be part of arbitrary many temporary collections.

        The card_id_str must be a string in the format 'card_xxxx_xxxx'.
        The temporary_collection_id_str must be a string in the format 'tmp_collection_xxxx_xxxx'.
        """
        # noinspection DuplicatedCode
        if not all(isinstance(x, str) and x.strip() for x in [temporary_collection_str, card_id_str]):
            raise ValueError("Question, answer, state, and flag must all be non-empty strings.")

        tmp_col_id = TmpCollectionID.from_hex_string(temporary_collection_str)
        temporary_collection = self.flashcard_manager.get_temporary_collection(tmp_col_id)
        card = self.flashcard_manager.get_card(CardID.from_hex_string(card_id_str))
        self.flashcard_manager.add_cards_to_temporary_collection(temporary_collection, card)

    # @llm_command(_commands)
    def temporary_collection_remove_card(self, temporary_collection_str: str, card_id_str: str) -> None:
        """
        Removes the given card from the given temporary collection. This does not delete the card from their 'normal' deck.

        The card_id_str must be a string in the format 'card_xxxx_xxxx'.
        The temporary_collection_id_str must be a string in the format 'tmp_collection_xxxx_xxxx'.
        """
        # noinspection DuplicatedCode
        if not all(isinstance(x, str) and x.strip() for x in [temporary_collection_str, card_id_str]):
            raise ValueError("Question, answer, state, and flag must all be non-empty strings.")

        tmp_col_id = TmpCollectionID.from_hex_string(temporary_collection_str)
        temporary_collection = self.flashcard_manager.get_temporary_collection(tmp_col_id)
        card = self.flashcard_manager.get_card(CardID.from_hex_string(card_id_str))
        self.flashcard_manager.remove_cards_from_temporary_collection(temporary_collection, [card])

    # @llm_command(_commands)
    def list_cards_temporary_collection(self, temporary_collection_id_str: str) -> ChunkedCardStream:
        """
        List all cards in a temporary collection, optionally filtering by a substring in the question.
        The temporary_collection_id_str must be a string in the format 'tmp_collection_xxxx_xxxx'.
        The cards will be returned in batches of 5.
        """
        tmp_col_id = TmpCollectionID.from_hex_string(temporary_collection_id_str)
        tmp_col = self.flashcard_manager.get_temporary_collection(tmp_col_id)
        return ChunkedCardStream(tmp_col.cards)

    # @llm_command(_commands)
    def add_all_cards_from_temporary_collection_to_deck(
        self, temporary_collection_hex_string: str, deck_hex_string: str
    ) -> None:
        """
        Add all cards from a temporary collection to the specified deck.
        The target deck may or may not be empty before this information.
        The newly added cards are copied, and independent of the source card.
        """
        deck_id = DeckID.from_hex_string(deck_hex_string)
        deck = self.flashcard_manager.get_deck(deck_id)
        tmp_col_id = TmpCollectionID.from_hex_string(temporary_collection_hex_string)
        tmp_col = self.flashcard_manager.get_temporary_collection(tmp_col_id)

        for card in tmp_col.cards:
            self.flashcard_manager.copy_card_to(card, deck)

    # Searching!

    def _search(
        self, deck_id_str: str, searcher: AbstractCardSearcher, description: str
    ) -> AbstractTemporaryCollection:
        """
        Search for cards in a deck given the searcher. May provide a description for the new TemporaryCollection.
        """
        if deck_id_str.strip() == "*":
            decks = self.flashcard_manager.get_all_decks()
        else:
            decks = [self.flashcard_manager.get_deck(DeckID.from_hex_string(deck_id_str))]

        cards = []
        for deck in decks:
            cards.extend(deck.cards)

        res_cards = searcher.search_all(cards)

        description = re.sub(r'[^\w .,?\'"]', "_", description)
        res_temporary_collection = self.flashcard_manager.create_temporary_collection(description, res_cards)

        return res_temporary_collection

    # @llm_command(_commands)
    def search_for_substring(
        self,
        deck_id_str: str,
        search_substring: str,
        search_in_question: bool = True,
        search_in_answer: bool = True,
        case_sensitive: bool = False,
        fuzzy: Optional[float] = None,
    ) -> AbstractTemporaryCollection:
        """
        Search for all cards in a deck that contain the given substring in the question or answer.
        Optionally uses fuzzy search (0 < fuzzy < 1), higher means that the substring similarity must be higher.
        A fuzzy threshold of 0.8 seems reasonable for most tasks.
        Using fuzzy search, you can reliably search for substrings even if there are unexpected special characters.

        If you want to search for a topic without knowing a keyword to search for, use "search_for_content" instead.

        If search_in_question is True, the question is searched, if search_in_answer is True, the answer is searched.
        If both are true, question and answer are searched.
        Make sure one of the arguments is true.
        If case_sensitive is True, the search is case-sensitive, else not.


        The deck id must be a string in the format 'deck_xxxx_xxxx', or '*' for all decks.
        A temporary collection containing responding cards will be returned.
        """
        if not isinstance(search_substring, str):
            raise ValueError("Search substring must be a string.")
        if (
            not isinstance(search_in_question, bool)
            or not isinstance(search_in_answer, bool)
            or not isinstance(case_sensitive, bool)
        ):
            raise ValueError("search_in_question, search_in_answer, case_sensitive must be booleans.")
        if not search_in_question and not search_in_answer:
            raise ValueError("search_in_question or search_in_answer must be True.")

        if fuzzy is None or fuzzy == 0.0:
            searcher = SearchBySubstring(search_substring, search_in_question, search_in_answer, case_sensitive)
            description = f"Search result for substring {search_substring} without fuzzy search."
        else:
            searcher = SearchBySubstringFuzzy(
                search_substring,
                search_in_question,
                search_in_answer,
                case_sensitive,
                fuzzy,
            )
            description = f"Search result for substring {search_substring} with fuzzy = {fuzzy:.3f}."

        return self._search(deck_id_str, searcher, description)

    # @llm_command(_commands)
    def search_for_content(
        self,
        deck_id_str: str,
        search_prompt: str,
        search_in_question: bool = True,
        search_in_answer: bool = True,
    ) -> AbstractTemporaryCollection:
        """
        Search for all cards in a deck that talk about the given topic using an LLM.
        This function is not limited to word matching and should be used if there is not a specific keyword to search for.
        The LLM will evaluate each card separately and decide whether it fits the search prompt.

        If search_in_question is True, the question is searched, if search_in_answer is True, the answer is searched.
        If both are true, question and answer are searched.
        Make sure one of the arguments is true.

        Examples for search prompts:
        * Cards containing information about trees.
        * Cards in German.
        * Cards about Machine Learning.
        * Cards about the Java constructor.

        The deck id must be a string in the format 'deck_xxxx_xxxx', or '*' for all decks.
        A temporary collection containing responding cards will be returned.
        """
        if not isinstance(search_prompt, str):
            raise ValueError("Search prompt must be a string.")
        if not isinstance(search_in_question, bool) or not isinstance(search_in_answer, bool):
            raise ValueError("search_in_question and search_in_answer must be booleans.")
        if not search_in_question and not search_in_answer:
            raise ValueError("search_in_question or search_in_answer must be True.")

        searcher = LLMSearchByContent(self.content_search_llm, search_prompt, search_in_question, search_in_answer)
        description = f"Search result for prompt {search_prompt} using an LLM to judge similarity."

        return self._search(deck_id_str, searcher, description)

    # @llm_command(_commands)
    def respond_to_question_answering_query(self, search_prompt: str) -> str:
        """
        Responds to a question from the user about available content in the SRS.
        The user can ask some arbitrary question which the LLM will try to answer.
        Therefore, call this method when general question answering is requested.
        Do not use this method for specific searches, e.g. searching for a keyword
        or topic, where the methods should provide sets of cards or temporary
        collections. This method is meant to provide a single answer
        to a question, not a set of cards.
        """
        return self.llama_index_executor.query_cards(search_prompt)
